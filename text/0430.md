## 3. 자바스크립트 개발 환경과 실행 방법  

자바스크립트는 브라우저와 Node.js 환경에서 실행할 수 있지만 브라우저와 Node.js는 존재 목적이 다르기에 ECMAScript 외의 추가적 기능은 서로 호환되지 않고 각각의 환경에 맞게 제공되는 API가 따로 있다.  

    질문1: 런타임은 코드가 실행되는 시점이고 런타임 환경은 코드가 돌아가는 환경이라고 이해하면 되는지?
    -> 그렇게 이해하면 된다.  

웹 브라우저에서 자바스크립트를 body의 아래쪽에 두어 DOM이 완성된 후에 조작할 수 있도록 하면 에러를 방지하고 렌더링에 지장을 주지 않을 수 있다.  브라우저의 개발자도구에서는 웹 개발에 필요한 여러 기능을 사용할 수 있다. 특히 콘솔에서는 에러를 확인하거나 간편하게 값을 확인할 수 있고, 에러 확인 후 Source 패널에서 바로 디버깅을 할 수 있어 유용하다.
서버 개발 환경을 제공하는 Node.js 에서는 서버 사이드 개발에 필요한 API를 제공한다.  
**Single Page Application**: 서버로부터 새로운 페이지를 불러오는 게 아니라 현재의 페이지를 동적으로 다시 작성하는 웹 애플리케이션이나 웹 사이트. 어떤 사이트에서 메뉴를 클릭했을 때 새로운 페이지를 불러오는 게 아니라 현재 페이지에서 내용만 바뀌도록 하는 것. HTML 페이지가 아니라 데이터만 오간다. 그래서 I/O가 빈번하게 일어남. 페이지가 하나뿐인 사이트. 싱글페이지.


## 4. 변수  

어떤 값을 메모리에 저장하고 재사용하기 위해 쓰는 것이 변수.  
var num = 10; 의 형태로 선언한다.  
변수에 값을 저장하는 것을 **할당**이라 하고 불러올 때는 **참조**한다고 한다.  
이때 var는 **키워드**, num은 **변수명(식별자)**, = 는 **할당연산자**, 10은 **변수값**이다.  
식별자는 단지 변수명만 뜻하는 것이 아니라 함수명이나 클래스 등 값을 구별하여 식별할 수 있는 모든 고유한 이름을 의미한다.  
자바스크립트 엔진이 키워드를 만나면 약속되어진 동작을 실행한다. 키워드는 일종의 명령어이다.  
var 키워드를 만나면 자바스크립트 엔진은 변수를 선언한다.
변수 선언에는 두 단계가 있다.  

1. 선언 단계:  
자바스크립트 엔진에 새로운 변수의 존재를 알려 값을 저장할 메모리 공간을 확보한다. 메모리 주소에 변수명을 매핑한다.  
2. 초기화 단계:  
선언 한 후 아무런 값도 할당하지 않으면 자바스크립트 엔진은 메모리공간에 undefined 라는 값을 암묵적으로 할당한다.  
초기화단계를 거치지 않으면 이전에 다른 애플리케이션이 사용했던 쓰레기값이 남아 참조될 수 있다.  

    질문2: 변수를 참조하는 것이 아무것도 없으면 자동으로 해제되는데 쓰레기값이 어떻게 남아있을 수 있는지?  
    -> 메모리는 브라우저만 쓰는 것이 아니라 다른 애플리케이션들과 함께 쓰는 것이다.  
    내가 변수를 직접 할당한 적이 한 번도 없지만 다른 애플리케이션이 썼을 수도 있고,  
    그래서 쓰레기값이 남아있을 수도 있다.  


변수를 사용하려면 꼭 선언을 해야 한다.  
내가 선언하지않은 변수를 불러오려하면 자바스크립트 엔진은 당연히 선언한 적 없는 변수명과 변수값을 찾아야하고 결국 못찾으므로 참조에러가 난다.  
**호이스팅**:  
Hoist = 들어올리다. 변수선언문이 마치 변수를 참조하는 코드 위쪽으로 끌어올려진 것처럼 동작하는 것.  
자바스크립트 엔진은 코드를 한 줄 한줄 읽어내려가기 전에 먼저 소스코드 전체를 평가하고 선언문을 찾아내서 식별자를 등록한다.  
그래서 변수선언문이 변수를 참조할 코드보다 늦게 쓰였음에도 참조에러가 나지 않는다.  
코드가 한줄씩 실행될때에는 이미 식별자가 등록이 된 상태이기때문이다. 단, 선언은 파싱타임때 되지만 값의 **할당**은 런타임에 실행된다.  

값을 재할당할때에는 메모리공간에 할당되어있던 원래 값을 지우는 것이 아니라 새로운 메모리 공간에 할당된다.  
그리고 이전에 할당된 메모리공간은 가비지컬렉터에 의해 자동으로 해제된다.


## 5. 데이터타입  

값은 데이터타입을 가진다. 데이터타입은 값을 저장할 때 확보해야하는 메모리공간의 크기를 결정한다.  
그리고 값을 불러올 때 그 데이터타입에 할당되는 메모리공간만큼 한번에 읽어야 손실이 없다.  
또한 그 읽어들인 2진수를 어떻게 해석할지 역시 데이터타입을 참고하여 결정한다.

    질문3: 데이터타입마다 할당되는 메모리 공간이 다르기 때문에 그 공간의 크기를 참고해서 어떻게 해석할지 결정하는 것인가?  

값: 더 이상 평가할 수 없다. 30을 평가하면 30이다.  
값을 생성하는 다양한 방법. 표현식.  
1. 리터럴 표기법: 리터럴을 생성.  
리터럴은 직접 고정된 값 자체.  
2. 표현식: 하나의 값으로 평가되는 문. 10+20을 평가하면 30이다.  

    질문4: 리터럴은 내가 직접 지정한 값이고 리터럴과 연산자의 조합인 표현식으로 만들어진 값은 리터럴이 아닌가? 왜 리터럴과 다른 값을 구분하는지?  

    질문5: 자바스크립트는 숫자타입을 왜 다 실수로 처리하나(컴공시간에 배운것같은데 잘 이해하지 못했음)  
    -> 자바스크립트는 다른 언어들과 달리 short, int, float 과 같은 다양한 숫자타입이 없으니까 
    International IEEE 754 standard에 따라 double로 처리하는 것이라고 한다.  

    질문6: 널값은 변수에 값이 없다는 것을 의도적으로 명시한것임에도 가비지컬렉터가 메모리를 해제하나?  
    어차피 가비지컬렉터에 의해 해제될 빈 메모리공간이라면 널값을 의도적으로 명시하는 상황은 어떤 경우인지?  
    그럼 널값 할당은 메모리공간을 비우라는 명령이 될 수도 있는건가?)    

    질문7: null의 데이터타입이 null 이 아니라 object 가 나오는 이유?  
    -> 설계의 문제인듯.. null타입 확인 시에는 일치연산자 사용할것.. 그럼 애초에 왜 그렇게 설계된건지)  

동적타입언어: 변수에 할당되는 값에 따라 데이터타입이 동적으로 바뀐다.  
정적타입언어: 선언된 변수의 데이터타입에 맞는 값만을 할당할 수 있다.  

## 6. 연산자  

문과 표현식.  
문(statement): 하나 이상의 표현식과 키워드의 조합으로 자바스크립트 엔진에게 내리는 명령.  
문이 실행되면 무슨 일이 일어나게 되어있다. 이 명령의 집합으로 이루어진 것이 프로그램. 문의 끝에는 세미콜론을 붙인다.  
표현식은 평가되어 값을 만들고, 문은 표현식으로 생성한 값을 사용해 명령을 내린다.  
표현식인 문은 값으로 평가할 수 있고, 표현식이 아닌 문은 값으로 평가할 수 없다.  

    질문8: 문이 표현식이 될 수 없다는 건 무슨 뜻인지  
    -> 표현식은 값을 만들어내는 것에 비해 조건문, 반복문 같은 문들은 값을 만드는 것이 아니라 어떤 일을 하기 때문임.  
    물론 표현식도 평가라는 일을 하고, 조건문도 비교연산을 통해 불리언 값을 만들긴 하지만,  
    그건 표현식과 문이 중점적으로 하는 일은 아니다.  

    질문9: 표현식이 문이 될 수 있다는 건 표현식이 어떤 값으로 평가되는 '일'이 일어나기 때문인가?  

이항산술연산자: 두 개의 피연산자를 산술연산하여 새로운 값을 만든다. 피연산자의 값이 바뀌지 않는다.  
단항산술연산자: 한 개의 피연산자를 산술연산하여 숫자타입값을 만든다. 피연산자의 값이 바뀐다.  

증가/감소 연산자(++/--)는 위치에 따라 의미가 다르다.  
피연산자 앞에 위치하면 먼저 피연산자의 값을 증가/감소 시킨 후 다른 연산을 수행하고,  
피연산자 뒤에 위치하면 다른 연산을 수행한 후에 피연산자 값을 증가/감소 시킨다.  

`+` 단항 연산자는 숫자타입이 아닌 피연산자에 사용 시 피연산자를 숫자타입으로 변환시킨 값을 반환한다.  
`-` 단항 연산자는 `+` 단항 연산자와 같은 기능을 하고, 피연산자의 부호를 반전한 값을 반환한다.  
삼항조건연산자: 조건식의 평가결과에 따라(조건식이 true일 때 & false일 때) 반환할 값을 결정.  

논리합 연산자(||) : 둘 중 하나만 true 이더라도 true 반환  
논리곱 연산자(&&) : 둘 다 true 여야 true 반환  
논리부정 연산자(!) : 부정을 긍정으로, 긍정을 부정으로 바꾼다.  
- !true = false  
- !false = true  
