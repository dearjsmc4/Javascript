## 함수와 일급객체  

**일급객체**: 값처럼 쓸 수 있는 객체  
객체는 변수에 담을 수도 있고 프로퍼티의 값으로 할당할 수도 있고 함수 인수로 전달하거나 리턴으로 반환할 수 있다. 함수도 위의 조건을 만족시키므로 일급객체이다.  

### 함수 객체의(함수 객체만이 가지고있는) 프로퍼티  

함수는 객체이므로 프로퍼티를 가질 수 있다.  
함수를 console.dir 로 찍었을 때 나오는 함수객체 고유의 프로퍼티는
arguments, caller, length, name, prototype 이렇게 다섯 가지이다.  

- `arguments`: 함수 호출 시 전달된 **인수들의 정보**를 가지고 있다.(중요함!!!) 
    유사배열객체이므로 for문 등으로 순회가 가능하다. 하지만 arguments는 프로퍼티처럼 쓰면 안 되고 함수의 암묵적인 지역변수처럼 써야 한다. arguments 객체는 매개변수 개수를 확정할 수 없는 **가변인자함수**에서 쓰면 좋다. 만약 for 문을 돌리면서 `arguments[i]` 이런 식으로 접근하는 것은 배열표현식이 아니라 프로퍼티접근이다. i 에 0, 1, 2, 3 이런 숫자들이 들어가더라도 숫자를 문자로 바꿔서 접근하기 때문에 사실은 `arguments.0` 이런식으로 접근하는 것과 같다.  

- `length`: **매개변수**의 개수를 가리킨다.  
- `name`: **함수명**을 나타낸다.  
- `prototype`: 함수만 가지고 있는 객체. 생성자 함수의 경우 함수가 생성할 객체의 프로토타입을 가리킨다.  


## 프로토타입  

```javascript
const me = new Object();
me.name = 'Rudy';

console.log(me);
// {name: "Rudy"}
console.log(me.hasOwnProperty('name'));
// true
```

Object 생성자 함수가 빈 객체를 만들고 내가 me 객체 안에 프로퍼티를 추가하였다. 그런데 me 객체는 내가 만들지 않은 여러 메소드들도 가지고 있다. 내가 선언하지 않았지만 쓸 수 있는 함수들이 있다는 말이다. `hasOwnProperty()` 역시 그 중 하나이다. 나는 이 메소드를 만든 적이 없지만 me 객체에서 사용할 수 있다. 왜냐면 모든 객체는 자신의 부모역할을 하는 프로토타입과 연결되어있다는 전제가 깔려있어서 그렇다.  

결론부터 말하자면 프로토타입 체인의 종점에 해당하는 `Object.prototype` 이 가지고 있는 메소드들은 모든 객체가 상속받아서 사용할 수 있다. 자식객체가 부모객체의 자산을 자신의 것인냥 사용할 수 있다는 것이다. 하지만 부모객체는 자식객체의 자산을 사용할 수 없다.(프로토타입 체인은 단방향 링크드 리스트로 구현되어있다.) 프로토타입 체인은 상속을 구현하는 방식이다.  

me 객체의 부모역할을 하는 프로토타입은 `Object.prototype` 이며, 따라서 me 객체는 `Object.prototype` 가 가지고 있는 모든 메소드들을 상속받아 사용할 수 있다.  


### Object 생성자 함수와 Object.prototype  

Object 생성자함수는 객체이면서 함수이며, prototype 이라는 프로퍼티를 가지고 있다. 이 prototype 프로퍼티는 함수 객체만이 가지고 있으며, `Object.prototype`을 가리키고 있다.  
```
생성자 함수 객체의 prototype 프로퍼티는 생성자 함수가 생성할 객체의 
프로토타입을 가리킨다고 했다. 일반함수도 가지고 prototype 프로퍼티를 가지고 있지만 
이 때에는 의미가 없다. 화살표함수나 메소드축약표현으로 만든 함수는 아예 이 메소드가 없다.  
```
그리고 모든 프로토타입 객체는 constructor 라는 프로퍼티를 가지고 있고, 이것은 생성자함수를 가리킨다. 그래서 Object 생성자함수와 `Object.prototype`은 서로를 가리키고 있다.  

`Object.prototype`은 프로토타입체인의 종점이다. 모든 객체는 `Object.prototype` 의 자식이고, 모든 객체는 `Object.prototype` 의 자산을 상속받는다. `Array.prototype` 이나 `Function.prototype`도 `Object.prototype`의 아래에 연결되어있다.  


### `__proto__` 접근자 프로퍼티  

프로퍼티에는 데이터프로퍼티와 접근자프로퍼티 두 가지 종류가 있다. 데이터 프로퍼티와 달리 접근자 프로퍼티는 value가 없다. 접근자 프로퍼티는 다른 데이터프로퍼티의 값을 가져오거나 변경/갱신할때 쓰는 것. 어떤 데이터프로퍼티 값을 보호하고 싶을 때, 혹은 조건에 부합할 때만 바꾸고 싶을 때 쓴다. `__proto__` 접근자 프로퍼티는 `Object.prototype` 에 있기 때문에 모든 객체와 함수가 사용할 수 있다. (모든 객체가 `__proto__` 를 '가지고 있는' 것이 아니다!)

`__proto__` 접근자 프로퍼티는 어디서 데이터를 가져올까?  
`[[Prototype]]` 내부슬롯에서 가져온다. 모든 객체는 자기가 생성될때 `[[prototype]]` 이라는 내부슬롯을 가지고, 이 안에 자신의 프로토타입 객체를 넣는다. 원래 직접적인 접근은 할 수 없지만, 간접적인 방법으로 접근을 허용한다.  
따라서 `me.__proto__ === Object.prototype` 은 true 가 된다. `__proto__` 접근자 프로퍼티를 이용하여 프로토타입을 교체하거나 프로토타입에 프로퍼티를 추가할 수도 있지만, 그보다는 `Object.getPrototypeOf` 메소드나 `Object.setPrototypeOf` 를 이용하는 것이 좋다. `__proto__` 접근자 프로퍼티는 객체의 프로토타입을 찾기 위한 것이고 원래는 직접 접근해서는 안 되는 프로퍼티이기 때문이다.  
