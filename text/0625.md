
## 생명주기  
태어나서 죽을 때까지의 과정. 컴포넌트가 생성되어서 Input프로퍼티에 값이 들어오거나, 변경되거나, 모든 뷰의 초기화가 완료되었을 때(컴포넌트가 사망하면) 그때마다 우리가 무언가 작업을 해야한다면 앵귤러는 그때 필요한 훅 메소드를 제공한다. 어떤 일을 아무 때나 하는게 아니라 타이밍에 맞춰서 해야한다는 것이다. 

(constructor는 생명주기와 큰 상관이 없음.)  

인터페이스는 하나 이상의 추상메소드를 가질 수 있다. 정의만 되고 실체가 없는데,
이것을 implement 했을 때에는 추상 메소드를 구현해야한다. 훅 메소드는 항상 `ng`가 붙고, 그 뒤의 이름은 인터페이스 이름과 일치한다. **ngOnInit**은 활용빈도가 높아 중요하다. 모든 초기화작업은 `ngOnInit`에서 하는 것이 좋다. 앵귤러는 자바스크립트와 달리 constructor에서는 많은 일을 하지 말 것을 요구하기 때문이다. (앞으로 웬만하면 constructor 에서는 아무것도 하지말고 대신 `ngOnInit`에서 하도록 한다)
앵귤러가 Input프로퍼티에 값을 넣어주는 것을 보장하는 때는 `ngOnInit`이 호출될 때이다.

- **ngOnChanges**  
Input프로퍼티가 있을 때, 처음으로 값이 들어오거나 변경되었을 때 실행된다.  

- **ngOnInit**  
무조건 한 번만 호출  

- **ngDoCheck**  
혹여나 변화를 감지하지 못하는 경우에 쓴다. 그러나 퍼포먼스상 안 좋으니 쓰지말자.  

<!-- 이제까지는 컴포넌트를 호출할때 컨텐트를 주지 않았지만, 원래 할 수 있다. 
<app-root>content</app-root> 컨텐트 프로젝션이라고 한다. -->

- **ngAfterViewInit**  
화면에 DOM요소를 동적으로 추가할 때 이 훅 메소드를 써야 한다. 
추가된 요소들은 DOM이 완성된 후에야 참조가 가능하니까, 이 메소드로 뷰가 모두 완성되면, 이라는 타이밍에 추가된 요소들을 이 메소드 안에서 참조하도록 한다. 

- ngOnDestroy  
컴포넌트와 디렉티브가 사망할 때  

## 서비스  
디자인패턴이 등장한다. 우리 선배들이 개발할 때 고민했던 부분들의 해결방법. 그래서 어렵다.  

서비스는, 우리 어플에서 중복적으로 사용하는 기능을 따로 떼어내는것. 마치 함수처럼!  
뷰를 담당하는 것이 아니기 때문에 템플릿이 없다.  

```typescript
// 루트컴포넌트
constructor() {
    this.greetingService = new GreetingService();
  }
```
루트컴포넌트가 인스턴스를 직접 생성한다면 서비스에 의존하고 있는 것이다. 인스턴스가 없으면 일을 못하기 때문이다. 이때 서비스를 `의존성`이라고 부른다.  
컴포넌트는 의존성의 메소드를 사용하기 위해서는 인스턴스를 직접 생성해야하며, 생성방법도 알아야하며, 메소드의 사용법도 알아야한다. 컴포넌트가 알아야할것이 너무 많다! -> 긴밀히 결합되어있다.  

이로인해 문제가 생긴다. 만약 서비스가 메소드의 이름을 바꾸거나, 인수를 안 받았었는데 받기로 바꾸거나 하면 컴포넌트의 코드도 바뀌어야한다. 만약 클래스의 이름이 바뀐다면 new 코드도 바뀌어야한다. 결국 **유지보수성이 나빠진다**. 서비스가 바뀌더라도 컴포넌트는 바뀌지 말아야 한다! -> 결합을 느슨하게 하자. 많은걸 알지않아도 되게.  

외부환경에게 의존성의 생성을 의뢰한다. 그리고 그 생성된 의존성을 주입받는것을 **의존성 주입**이라고 한다. 
외부환경에서 어떻게 생성해야하는지 정보가 필요한 건 변함없다. 그러나 컴포넌트는 생성방법을 몰라도 된다.  

```typescript
  constructor(private greetingService: GreetingService) {}
```
이때 GreetingService가 greetingService를 만드는 서비스인지는 알 수 없음. 반드시 만들어 줄 것이라는 보장이 없다. 

```typescript
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
```
서비스에 이 내용이 있어야 한다. 특히 `providedIn: 'root'` 는, 애플리케이션 전역에서 사용할 수 있는 서비스가 된다는 뜻이다. 이걸 안 써주면 서비스가 아니며, 주입할 수 없다.  

아니면 루트모듈이나 루트컴포넌트에 아래와같이 추가한다.
`providers: [GreetingService]`
그러나 만약 루트컴포넌트에 등록하면, 루트컴포넌트와 루트컴포넌트의 자식들만 서비스를 참조할 수 있다. 스코프가 제한된다. 
따라서 모든 서비스가 전역서비스라면 서비스에서 등록한다.(만약 서비스에 등록했다면 루트모듈에 providers에 추가하지 않는다)  


## 쉐도우 DOM 스타일 셀렉터  
앵귤러가 제공하는 스타일 셀렉터. 웹 컴포넌트에 있는 내용이다. 이것은 앵귤러가 아니라 W3C가 관리한다. 우리가 커스텀한 컴포넌트는 아예 `display`(block/inline-block/inline 등)속성이 없다. 그러나 브라우저가 기본적인 CSS를 가지고는 있다. 그래서 브라우저마다 외양이 조금씩 다른 것이 문제가 되니까 리셋 CSS를 쓰는 것이다. 컴포넌트는 앵귤러가 제공하는 스타일 셀렉터를 이용할 필요가 있다.  

## RxJS  
'Rx' = 리액티브 프로그래밍  
이것은 자바스크립트에 한정된 기능이 아니고 새로운 패러다임이다. 객체지향 / 절차지향과 유사한 느낌.  
앵귤러는 기본적으로 리액티브 프로그래밍을 지원한다. 앵귤러에서 템플릿에 쓰는 모든 요소는 리액티브하게 코딩할 수 있으며, 그 기능을 다 제공하고 있다. 

이제껏 내가 했던 모든 프로그래밍은 *입력 -> 로직 -> 출력* 의 반복이었는데,  
문제는 입력의 형태가 다를 수 있다는거다. 문자, 숫자, 객체, 함수, 프로미스, 이벤트 등등. 
입력값의 종류에 따라 코딩하는 방법이 제각각이었고 이런 방식이 혼란을 일으킨다(비동기입력의 경우 특히나).  
입력이 동기데이터인지 비동기데이터인지 보고 코딩방식을 결정했었다.  
그런데 RxJS는 **이렇게 하지말고, 정적데이터든 동적데이터든 동기든 비동기든 전부 다 stream으로 만들자!!!**
데이터소비자는 가만히 있고, 데이터가 알아서 물길타고 흘러내려오는 것이다. 이벤트처리와 비슷하다. 우리가 가만있어도 이벤트는 주입되었었고, 우리는 할 일만 입력해줬었다. 
입력데이터는 **옵저버블**이라는 하나의 타입으로 맞춰버리자.

리액티브 프로그래밍은 **푸시 시나리오**를 기본으로 한다. 데이터 프로바이더가 무조건 데이터를 송출하며, 데이터 소비자가 그걸 알아서 받는다. 우리는 밀려들어오는 데이터에 **'반응'**을 한다고 해서 리액티브 프로그래밍이다.

외부 환경에서 애플리케이션 내부로 연속적으로 흐르는 데이터, 즉 데이터 스트림을 생성하고 방출하는 객체를 **옵저버블**(Observable)이라 하고 -> 방송국
옵저버블이 방출한(emit) **노티피케이션**(Notification: 옵저버블이 방출할 수 있는 푸시 기반 이벤트 또는 값) -> 영상정보  
... 을 획득하여 사용하는 객체를 **옵저버**(Observer)라 한다. -> 내 티비  
옵저버는 데이터 생산자(Data producer)인 옵저버블을 **구독**(subscription)한다. -> 지켜보고있다, 관측하고있다  
그러니까 옵저버블과 옵저버는 구독이라는 관계로 이루어진 것이다.  

옵저버블과 옵저버가 일대다의 관계일 수 있다. 방송국은 하나지만 티비는 여러 개인 것처럼.  
RxJS에서 제공하는 메소드들은 다 **오퍼레이터**라고 부른다.  

### 옵저버패턴  

**Subject:**  
- 데이터  
  `ObserverCollection`- 옵저버들의 모음  
- 메소드  
  `register`: 옵저버 등록  
  `unregister`: 옵저버 삭제  
  `nofity`: 전달하려는 메세지를 옵저버에게 보내기  

**Observer**  
- 메소드  
  `update`: 상태 변화에 대응  

서브젝트는 데이터가 바뀌면 자신을 구독하는 모든 옵저버들에게 새로운 데이터를 `notify` 하고, 옵저버들은 데이터가 바뀌면 최신데이터를 무조건 받는다(`update`).
옵저버패턴은 이해가안되면 외워야 한다.  

