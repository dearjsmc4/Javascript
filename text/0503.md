
## 변수  

들어가기 전에.  
- 자바스크립트는 왜 8바이트 숫자를 쓰는가  

자바스크립트의 변수에는 숫자, 문자, 불리언 등을 자유롭게 넣을 수 있다. 즉, 변수에 뭐가 들어올지 모른다는 말이 된다. 그래서 메모리 공간을 좀 넉넉히 확보한다. 다른 언어같으면 '이 변수는 4바이트 정수 숫자를 저장할거야' 라고 크기를 딱 정해줄텐데, (선언될 때 타입을 정하니까 `정적 타입 언어` 라고 한다.) 자바스크립트는 **동적 타입 언어**라서 크기를 정해주지 않는다. 변수의 타입은 할당될 때의 값의 타입에 따라 정해진다.   

숫자의 크기가 8바이트면 8개의 셀을 쓸 것이고, 8개의 주소가 있을 것이다. 이때 변수는 선두 어드레스를 기억하고, 변수값을 불러올 때 몇 바이트를 가지고 와야할지 알아야 하는데, 그것은 데이터 타입으로 결정한다. 데이터 타입의 크기를 참고(메모리 공간을 얼마나 차지하고 있나)하여 그만큼의 데이터를 전부 불러온다. 만약 가져와야하는 바이트보다 조금 가져오면 데이터가 왜곡되기 때문이다.


### 변수의 재할당  

`var x;`
`x = 10;`  
`=`: 우변의 값을 좌변으로 할당하는 할당연산자  

변수가 선언되면, 선언과 초기화단계를 거쳐 변수명과 메모리공간이 매핑되었고 undefined 가 할당된 상태가 된다. 그리고 런타임에 자바스크립트엔진이 10 이라는 숫자(값)를 이진수로 바꿔서 메모리 공간에 값을 넣는다.  

**!중요!**

undefined를 싹 지우고 숫자를 그 자리에 넣는게 아니라, **새로운 공간에 숫자를 넣고 변수 x가 그 공간을 가리키게** 한다. 원시타입은 변경불가능한(immutable) 값이기 때문이다.  

undefined는 데이터타입이면서 값이기도 하다. 그러니까 할당이 될 수 있다. undefined는 원시타입이고, 변경할 수 없다.  
-> 메모리공간에 할당된 undefined를 지우고 다른 값으로 바꿀 수 없다는 뜻이다.  
undefined가 할당된 공간은 그냥 놔두고, 새로운 공간에 10이라고 이진수로 쓰고 x 가 10을 가리키게 한다. 그럼 undefined는 쓰레기값(어떤 식별자도 참조하지않는 값)이 된다. 쓰레기값이 되면 가비지컬렉터가 치운다. (언제 치울지는 모른다 그건 개발자가 신경 쓸 일은 아니다)  
이것이 자바스크립트에서의 변수의 **재할당.**  


### 변수 호이스팅

선언만 된 상태에서 참조했을 때 초기화된 상태인 undefined 가 나오는 현상.  
(호이스팅을 배우는 이유는 쓰라고 배우는게 아니라 쓰지말라고 배우는 거라고 하셨다...)  
```javascript
var a = 1
function test(){
    console.log(a);
    var a = 100;
    console.log(a);
}
```
var 키워드를 사용했으므로 첫 번째 a는 undefined, 두 번째 a는 100이 나온다.  
자바스크립트 엔진이 변수 선언문을 실행한 후에 코드를 한 줄씩 실행하면서 값을 할당하게 되는데,  
함수 내에서 첫 a를 콘솔에 출력하려고 할 때에는 아직 100 이라는 값이 할당되지 않아 undefined 인 상태다.  
두 번째 a를 출력할 때에는 a에 100이 할당 된 후이기 때문에 100이 정상적으로 출력된다.  

- var 키워드의 문제:  
    - 중복선언이 된다.  
    - 호이스팅이 된다.  
    - 키워드 없이 선언되면서 심지어 전역변수가 된다.  
    - 블록레벨스코프를 지원 안하고 함수레벨스코프를 지원. 
    - 상수 선언이 안 된다. (상수는 재할당을 못하는 변수. 상수도 변수다!)  
    (변수명을 대문자로만 지으면 상수란 뜻으로 통한다고 한다)  

그래서 ES6에서 const 와 let 키워드가 도입되었다.  
const: 할당 한번만 가능  
let: 재할당가능  
둘 다 변수호이스팅을 안하는 것처럼 동작한다.


## 값  

더 이상 평가될 수 없는 표현식.  
10+20 이 왜 표현식일까? 평가라는 단계를 거쳐 30이라는 하나의 값을 만들기 때문이다.  
그럼 30은 왜 표현식이냐. 30도 30으로 평가되니까.  
정확히는, 30도 메모리에 들어갈때 컴퓨터를 위해 이진수 값으로 평가되어 들어가기 때문이다.

### 리터럴  

리터럴이라는 상태는, 내가 그냥 30이라고 쓴 상태다. 리터럴 표기법이 별 게 아니고 그냥 내가 10이라고 쓰면 그게 리터럴 표기법으로 만든 리터럴이다. 30은 숫자 리터럴이고, 자바스크립트엔진이 30을 읽고 "아 숫자 30을 만들라는 거구나," 하고 
숫자 30에 대응하는 값(이진수)을 만든다. 30이라는 리터럴이 이진수값으로 평가되었다. 결국 **리터럴은 값을 만드는 방법중에 가장 심플한 표현식** 이다.  

정확히는 리터럴은 값이 아니라 값을 만드는 표현식이다. 근데 어차피 리터럴은 값이 될 예정이니까 그냥 값이라고 퉁칠 수도 있다. 리터럴은 값이 될 순 있지만 값이 리터럴이 될 수 없다는건 리터럴이 평가되서 값이 될 수는 있지만 값이 평가되어 리터럴이 될 수는 없다는 말이다. 


## 표현식  

변수에 할당되는 것은 값으로 평가될 수 있는 모든 표현식이다.
`var a = 10;`
이 때 콘솔창에서 a 를 입력하면 10이 나온다. a 도 평가되어 10이 나왔다는 뜻이다.  
이때 a 를 **식별자 표현식**이라고 한다.  
`a + 10` 은 a 라는 식별자 표현식과 10 이라는 리터럴 표현식이 합쳐진 표현식이다.  
그래서 표현식은 표현식의 일부가 될 수 있다는 것을 알 수 있다.  


## 문  

문은 하나의 키워드와 식별자로 이루어진 명령이다.  
`var foo;` 는 선언'문'이다. 왜? var 와 foo 로 이루어진 변수 선언명령이기 때문이다.  


## 표현식 vs 문  
표현식은 값을 만드는게 주 업무이며, 문은 무언가를 실행하거나 명령하는 것이 주 업무다.  
문의 개념이 좀 더 포괄적이다. 따라서 표현식은 문이다. 평가하여 값을 만들라는 일종의 명령이기 때문이다. 하지만 우리는 보통 표현식은 '평가'를 한다고 하지, '명령'한다고는 하지 않는다. 표현식은 '평가'가 주 업무다.  

문은, 표현식인 문과 표현식이 아닌 문이 있다.  

- 표현식인 문 : 값을 만드는 일을 하는 문  
- 표현식이 아닌 문 : 값을 만드는 일이 아닌 다른 일을 하는 문  

둘을 구별하는 가장 쉬운 방법은 변수에 할당해보는 것이다.  
할당이 잘 되면 표현식인 문이고, 안 되면 표현식이 아닌 문이다.  
가장 쉬운 예로는, if문은 표현식이 아닌 문이다. if문을 변수에 넣지는 않는다.  

(+)
자바스크립트의 할당문은 식이다.  
`sum = 10;` 을 콘솔창에서 출력해보면 10으로 평가되어 나온다. 값으로 평가되는 표현식이라는 뜻이다.  


## 데이터 타입  

### 문자열 타입  

자바스크립트엔진은 문자열의 크기를 보고 크기에 맞는 메모리공간을 확보한다.
문자열을 따옴표로 묶는 것은 식별자로 오해하지 않게 하기 위해서고, 문자열의 시작과 끝을 알리기 위해서이기도 하다. 마치 열고 닫는 태그같은 것이다.  
ES6부터는 템플릿 리터럴이 도입되었는데, 1+1 같은 산술연산이 들어가도 평가 후에 문자열로 변환된다. 

### undefined  
변수가 선언되었을 때, 개발자가 보기에는 선언만 되고 할당이 되지 않은 상태이지만 사실 자바스크립트엔진에 의해서 선언과 동시에 undefined가 할당된 상태다(값이 할당되었으니 정의도 되었다). undefined는 개발자가 직접 할당하는 것이 아니다. 할당은 자바스크립트엔진이 해주고, 나는 그게 "할당이 안된 상태구나," 하고 인식하면 된다. 내가 일부러 undefined를 할당할 일이 얼마나 있을까.  

### null  
변수에 null 을 할당하면 변수가 참조하고 있던 값 말고 null 을 가리키게 한다. null은 값이 없다는 뜻이니까, 변수가 가리키는 값은 '없다'. 참조가 끊어지게 된다.  
null 을 할당하게 되면 자연스레 변수가 원래 참조하고 있던 메모리 공간이 해제되지만, null은 값이지 메모리 공간을 해제하라는 명령어가 아니다. null 을 할당하는 것은 그다지 효율적이지 못하기도 하다.  
a가 null 을 바라보게되면 a가 바라보던 값이 혼자 남게 되어 쓰레기값이 된다? 그럴거면 null을 쓰나 다른 값을 쓰나 똑같고, 그럴거면 스코프를 줄여서 변수를 소멸시키는 게 낫다.  
(함수는 null 에서 자주 쓰인다고 한다. 리턴값이 없을때 에러를 내보내면 멈추니까 그냥 null 을 리턴해버린다고...)  


## 잘 모르는 내용 복습/정리  

- **데이터타입 :** 동적타입과 정적타입  
정적타입 언어는 변수를 선언할 때 아예 데이터타입을 고정시켜놓는다. `int a` 이렇게. 그래서 a에는 int형의 데이터가 아니면 들어갈 수 없다. 자바스크립트는 동적타입언어다. 내가 `let a` 라고 선언했을 때 데이터타입을 고정시켜놓지 않았다. a에는 숫자도 문자도 함수도 객체도 다 들어갈 수 있다. 데이터타입은 값이 할당될 때 결정된다. `let a = 10` 일때, 자바스크립트 엔진은 let 키워드를 만나 식별자 a를 등록한다. 런타임 때에 다시 돌아오면 = 이라는 할당연산자를 만나고 그 뒤에 있는 10을 숫자타입으로 인식한다. 숫자타입으로 인식한 10을 a라는 메모리공간에 할당한다. 이렇게 값에 따라 데이터타입이 동적으로 결정되는 언어를 동적타입언어라고 한다. 

- **표현식과 문**  
연산자는 피연산자를 받아 특정 연산을 해서 값을 만든다. 값을 만드는 것은 표현식. 문은 무엇인가?  
값으로 평가될 수 있는 문은 표현식인 문이며 그렇지 않은 문은 표현식이 아닌 문이다. 표현식은 식별자, 키워드, 리터럴, 함수호출 등의 조합이다. 10+20 과 같은 연산자 표현식도 있고 10 과 같은 리터럴 표현식도 있고 foo(1,2)처럼 함수호출표현식도 있고 a 같은 식별자 표현식도 있다.(a에 값이 할당되어있다면 a는 평가되어 그 값이 된다) 표현식은 값을 만드는 것 외에 다른 일은 할 수 없다. 하지만 문은 if, while, for 문으로 프로그램의 흐름을 제어할 수도있고, var, let, const, function 등의 키워드를 만나 자바스크립트엔진에 명령을 내릴 수도 있다. 문은 하나 이상의 키워드와 표현식으로 이루어진 명령이다. 문의 끝에는 세미콜론을 붙여야하지만 코드블록에는 세미콜론을 붙이지 않는다. 문에는 제어문(if, for, while 등), 함수선언문(function foo () {}), 변수선언문(var a;), 할당문(x = 10) 등이 있다. 제어문, 함수선언문, 변수선언문은 값으로 평가될 수 없으므로 표현식이 아닌 문이고, 할당문은 값으로 평가될 수 있으므로 표현식인 문이다. 표현식이 아닌 문과 표현식인 문을 구별하는 가장 쉬운 방법은 변수에 할당해보는 것이다. 변수에는 하나의 값을 저장할 수 있다고 했다. 그렇다면 값으로 평가될 수 있는 표현식인 문은 변수에 할당할 수 있을 것이고, 값으로 평가될 수 없는 표현식이 아닌 문은 변수에 할당될 수 없을 것이다. 결국 프로그램은 문들의 조합이다. 
