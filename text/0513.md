## 엄격모드  

오타나 문법 지식의 미비로 인한 잠재적인 오류를 발생시키기 어려운 개발 환경을 만들어 안정적인 코드를 생산하기 위해 ES5부터 엄격모드가 추가되었다. ESLint와 같은 도구를 사용하여도 엄격모드와 유사한 효과를 얻을 수 있다.  

엄격모드를 적용하려면 전역의 선두 또는 함수 몸체의 선두에 `'use strict;'` 를 추가한다. 엄격모드는 즉시실행함수로 감싼 스크립트 단위로 적용하는 것이 바람직하다. 

### 엄격모드가 발생시키는 에러  

- 암묵적 전역변수 : 선언하지 않은 변수를 참조하면 ReferenceError 가 발생한다.  
- delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생한다.  
- 중복된 함수 파라미터 이름을 사용하면 SyntaxError가 발생한다.  
- with문을 사용하면 SyntaxError가 발생한다.  
- 일반함수를 호출하면 this에 undefined가 바인딩된다. 에러는 발생하지 않는다.  

## 전역객체  
전역객체는 브라우저를 켜자마자 만들어지며 어떤 객체에도 속하지 않은 최상위 객체이다. 개발자가 의도적으로 생성할 수 없다. 그 안에는 전역객체가 가지고있는 프로퍼티와 메소드, var 로 만든 전역 변수, 암묵적 전역변수, WEB API가 들어있다. window의 프로퍼티는 `window.`을 생략해도 된다.  

- Infinity : 양/음의 무한대를 나타내는 숫자값  
- NaN : 숫자가 아님을 나타내는 숫자값  
- undefined  
- eval 함수 :  
매개변수에 전달된 코드를 나타내는 문자열을 평가/실행 하고 결과값을 반환한다. eval코드는 런타임에 스코프를 동적으로 수정한다. eval 함수로 사용자로부터 입력받은 콘텐츠를 실행하는 것은 보안에 매우 취약하다. 최적화도 수행되지 않아 처리속도가 느리다.  

## this  

객체에는 상태 데이터와 동작(메소드)이 있다고 했고, 동작인 메소드는 상태 데이터를 참조하고 변경할 수 있어야 한다. 메소드가 자신이 속한 객체의 프로퍼티를 참조하려면 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.  
**this**는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 **자기참조변수**이다. **this가 가리키는 값은 함수 호출 방식에 의해 동적으로 결정된다.** 아무것도 신경쓰지말고 함수가 어떻게 호출되었느냐만 보면 된다. 함수가 호출되어야 this 가 결정된다.  

### 다양한 함수호출방식  

1. 일반함수 호출 -> this 는 기본적으로 window 를 가리키도록 세팅된 채로 시작한다.  
2. 메소드 호출 -> this 는 메소드를 호출한 객체를 가리킨다.  
3. 생성자함수 호출 -> this 는 생성될 인스턴스를 가리킨다.  
4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출 -> this를 명시적으로 바인딩  

this는 객체의 참조를 얻기 위해 필요한 것이니까 전역이나 일반함수에서 this를 쓸 일은 없다. 그래서 엄격모드에서는 undefined를 내보낸다.  

메소드로 호출된 함수는 메소드를 **호출한** 객체를 가리킨다고 했다. 메소드를 **가지고 있는** 객체가 아니다! this 가 무엇인지 확인할 때에는 무조건 함수가 **어떻게** 호출되었는지만 확인하면 된다. 즉시실행함수도 this 가 window 이다. 메소드 안의 중첩함수도 일반함수로 호출되었다면 this 는 window 이다.  
그런데 중첩함수는 외부함수를 도와주는 함수이다. 외부함수 안에서만 딱 쓰겠다는 의지가 나타났다는 말이다. 그럼 외부함수가 메소드로 호출돼서 this 가 객체를 가리키는 상태라면, 중첩함수에서 this가 window로 바뀌는 것은 기대에 어긋난다. 그래서 필요하다면 this를 갈아끼워줄 수 있다. 외부함수에서의 this를 변수에 회피시켜놓고 쓸 수도 있지만, bind/apply/call 빌트인 메소드를 사용할 수도 있다. 위 목록 중 4번 항목을 말하는 것이다. 

- apply 와 call  

함수를 호출하는 것이 주 역할인 것은 똑같고 인수를 전달하는 방식만 다른 메소드들이다.  
```javascript
foo.apply(thisArg, [argsArray])
```
foo.apply(thisArg) 일 때, foo함수를 호출하면서 인자로 준 thisArg를 this로 바인딩해준다(간접호출도 해준다). 인수가 있을 때 인수도 전달할 수 있다. `[argsArray]` 는 함수에 전달할 인수 리스트 배열이다. 옵션이므로 생략 가능하다.  

```javascript
foo.call(thisArg, arg1, arg2, ...)
```
call 메소드도 첫 번째 인자를 this 로 바인딩해주고 간접호출까지 해주는 것은 같다. 하지만 인자를 전달하는 방식이 apply 와는 다르다. 배열의 형태가 아니라 하나씩 전달해야 한다.  

- bind
호출을 자동으로 해주진 않고, 사용할 객체를 this로 전달하는 것까지만 해준다.  
메소드의 this와 메소드 내부의 중첩함수 또는 콜백함수의 this가 불일치하는 문제를 해결하기 위해 사용된다. 
