## 정규표현식  

Regular Expression, 줄여서 RegExp 라고 한다. 문자열에서 특정 내용을 찾거나 대체, 또는 발췌하는데에 사용한다. 반복문이나 조건문 대신 정규표현식을 쓰면 더 간단할 수 있지만 가독성이 좋지 않다.  

### 플래그  

플래그는 옵션이다.  

- i (Ignore Case) : 대소문자를 구별하지 않고 검색  
- g (Global) : 문자열 내에서 모든 패턴 검색  
- m (Multi Line) : 문자열의 행이 바뀌어도 계속 검색  

```javascript
const str = 'Friday I am in love.';

// 대소문자를 구별하여 한 번만 검색 
let reg = /i/; 
console.log(str.match(reg)); 
// ["i", index: 2, input: "Friday I am in love.", groups: undefined]

// 대소문자를 구별하지 않고 전체 검색  
reg = /we/ig;
console.log(str.match(reg)); 
// (3) ["i", "I", "i"]
```

### 패턴  

패턴에는 검색하고 싶은 문자열을 지정하며, 따옴표는 생략한다. 특별한 의미를 가지는 메타문자 또는 기호로 표현할 수도 있다.  

- `.` : 문자 한 개를 검색  

```javascript
const str = 'Friday I am in love.';
// . 은 문자 한 개를 의미한다.  
let reg = /.../;
console.log(str.match(reg));
// ... 패턴이므로 3자리 문자가 추출된다.  
// ["Fri", index: 0, input: "Friday I am in love.", groups: undefined]

// 3자리 문자를 반복 검색  
reg = /.../g;
console.log(str.match(reg));
(6) ["Fri", "day", " I ", "am ", "in ", "lov"]
```

- `+` : 지정 문자가 한 번 이상 반복되는 문자열을 검색  
- `|` : or 과 같은 기능을 한다.  
- `[]` : `[]` 내의 문자는 or 로 동작한다. 범위를 지정하려면 `-` 를 사용한다.  

자주 쓰는 정규표현식은 스크랩해두는 것이 좋다.  

- match 메소드를 썼을 때 일치하는 결과가 없으면 결과가 null 이다.  


## 배열 고차 함수  

함수는 객체이며, 함수를 값처럼 쓸 수 있다고 했다. 그래서 함수는 일급객체이다. 함수형 프로그래밍에서는 클로저가 매우 중요하다. 클로저 적극사용!  

콜백함수는 그 함수를 인수로받은 함수가 자기가 원할때 호출한다.  
함수는 자기가 정의될 때 상위스코프가 결정된다. 호출될 때가 아니다! 그리고 함수는 자기의 상위스코프를 언제나 기억하고 들고 다닌다. 상위스코프를 계속 참조하고 있으므로 가비지컬렉터가 지우지 않는다.  

고차함수는 1. 함수를 인수로 전달받거나, 2. 함수를 리턴하거나, 3. 둘 다 하는 함수를 말한다.  
함수를 밖에서 만들어서 안으로 던져주는 건 함수를 합성하는 일이다. 전달된 함수의 도움을 받아 본 함수의 내용을 바꾼다. 즉, 바깥에서 주는 함수에 따라 함수의 동작이 달라진다. 본 함수는 그대로 있고 밖에서 일부함수만 던져주면 바뀌는 부분도 줄고 유지보수 하기 좋아진다.
고차함수는 가변 데이터를 피하고 불변성을 지향. 외부상태가 안 바뀌었으면 좋겠다는 것이다. 외부상태에 의존하지않고 외부상태를 변경하지않는 순수함수를 추구하는 것이 함수형 프로그래밍이고, 그런 매커니즘이 녹아있는 것이 고차함수.  

### sort()  

정렬할 때 배열의 요소들을 내부적으로 문자열로 바꿔서 비교하기 때문에 숫자 정렬 시에 원하는대로 나오지 않을 수 있음. 유니코드 순서에 따라 정렬하기 때문에. 그래서 숫자정렬할때는 함수를 준다.  

`function (a, b) { return a - b; }` 이 함수를 인수로 주면 오름차순이 되는데,  
어떻게 이렇게 되는지 까볼 필요까지는 없고 그냥 받아들이라고(...)  
`function (a, b) { return b - a; }` 는 내림차순.  

`a[key] > b[key] ? 1 : (a[key] < b[key] ? -1 : 0`  
-> 숫자일때 문자일때 모두 적용할 수 있는 삼항연산  

### forEach  

for문 대신 쓸 것.  

<!-- 앞으로 forEach map reduce some find filter 등을 쓰고, for문은 금지.
(근데 만번돌아야된다 그러면 성능상 for문 쓰겟지...)
`map`, `filter`, `reduce` 를 잘 이해해야 한다.  -->

forEach에 함수를 주고, forEach가 함수를 호출할 때 forEach는 자기가 호출한 함수에 인수를 줄 수 있다. **배열 요소의 값, 그 요소값의 인덱스, this.** 

```javascript
numbers.forEach(function (item) {
  pows.push(item ** 2);
});
```

각 요소(item) 에 대해 함수를 실행. 내부적으로 for문은 돌고있다. 함수는 요소(this)의 갯수만큼 실행되고, 함수를 호출한 객체가 인수를 넣어주는 것이다. 이때 this는 함수를 호출한 배열 자체이다. forEach는 반환값이 undefined. 즉, 리턴문이 없다. 리턴을 쓰면 무시한다. forEach는 모든 요소를 순회하면서 함수를 실행한다. for문처럼 거꾸로 돌리거나 한 칸 건너뛰고 돌거나 break 거는 것은 할 수 없다.  
for문에서도 증감식에 i++ 나 i--는 되지만 2를 더하거나 곱하거나 하는 건 좋은 코딩이 아니다. 만약 1씩 증가한다고 생각하고 코드를 짜면 에러가 날 수도 있으니까. for문은 사람이 인식하기에 좋지 않은 문법이고 가독성이 안 좋다.  
forEach안에서 브레이크를 쓰면 에러다. 브레이크는 어떤 조건에 충족 시에 순회를 중단하겠다는건데 그건 filter 로 해결이 가능하다.  
this를 고칠 수 있는 능력은 forEach에게는 없고 콜백에게는 있다. 왜냐면 콜백은 세번째 인자로 this를 받을 수 있으니까.  
forEach는 for문처럼 변수선언이나 조건식 증감식이 따로 필요가 없다. 
forEach는 콜백함수를 일반함수로 호출한다. 그 때 콜백안에서의 this는 윈도우. forEach는 첫번째 인수로 함수를 주고, 두번째 인수로 this를 전달할 수 있다. 그럼 forEach를 호출한 객체가 this가 되어서 전달된다.  

### map  

this와 똑같은 갯수의 리턴을 만들어내고 싶을 때 쓴다. 어떤 배열이 있고, 그것을 map 한다고 하면 반환한 배열의 요소들은 원본 배열과 매핑된다. 원본배열의 갯수를 초과하거나 적어지지 않는다. 매 요소마다 콜백함수를 실행하여, 그 결과값으로 이루어진 새로운 배열을 반환한다. 결과값을 새로운 배열에 담아서 리턴하는 것이다. 리턴은 새로운 배열에다가 결과값을 푸쉬하는 것과 같은 동작을 한다. 그 요소의 수는 원본과 반드시 일치한다. map의 활용도는 무지하게 높다! 얘는 반드시 함수를 실행한 뒤 리턴을 해줘야 한다. 만약 리턴하지않으면 빈 배열이 나온다. 그리고 새로운 배열을 반환하기 때문에 변수로 받아주어야 한다. 원본 배열을 수정하지 않는다. forEach처럼 순회하며 콜백을 실행하는 것은 똑같다. 인수로 받는 것들도 똑같다.  

### filter  
this배열에서 어떤 조건에 부합하는 요소들만으로 구성된 배열을 리턴한다. 따라서 이론상 this배열보다 리턴되는 배열의 요소의 수는 같거나 적을 수 있다. 원본배열을 수정하지 않는다. forEach가 for문을 대체할 수 있듯, filter는 if문을 대체할 수 있다. 리턴문에는 불리언으로 평가되는 표현식을 넣는다. if문이라고 생각하면 된다. 그 조건에 부합하는 요소들이 리턴된다.  

### reduce  

값을 두 개를 가지고 함수를 실행하며, 이전 콜백에서 실행한 결과를 다음 콜백의 첫 인수로 넘겨준다.  


### 그 외

- some : 배열 내의 일부 요소가 조건에 맞는지 확인하여 불리언 반환  
- every : 배열 내의 모든 요소가 조건에 맞는지 확인  
- find : 조건에 맞는 첫 요소를 반환  
  여기서 콜백의 매개변수로는 객체가 들어온다. 배열이 아니라 요소를 반환함  
- findIndex : 조건에 맞는 첫 요소의 인덱스를 반환. 만약 find를 못 쓰면 filter를 쓰면 된다.   

- Object.assign : 뒤에서 앞으로 머지.

## 화살표 함수  

인수를 함수 몸체 안으로 넘겨준다고 이해하면 된다. 호출할 때에는 함수 표현식을 사용한다. 화살표함수는 this가 없고, 함수가 **정의될 때** 자신이 정의된 상위스코프의 this를 승계받는다. 자기가 this를 가지고 있는 것이 아니다. 왜냐면 얘는 콜백함수로 쓰려고 만들었기 때문에. 그러면 콜백을 쓸 때 따로 this를 바인딩해주지 않아도 되니까.  

- this를 바인딩하는 방법 4가지.  
  that에 담거나  
  map의 두번째 인자에 주거나  
  bind를 주거나  
  화살표 함수를 쓴다.  

화살표함수는 `[[constructor]]` 가 없다. 생성자함수로 만들 수 없다.
this도 없고 arguments도 없다.  

- rest 파라미터(...rest)  
이걸 쓰면 arguments를 안 써도 된다. arguments는 유사배열객체이기 때문에 배열화 해서 써야했지만 rest를 쓰면 그럴 필요가 없다. rest파라미터는 단독으로 쓰이거나 맨뒤에 쓰여야한다.

- spread 연산자  
rest파라미터하고 헷갈리면 안 된다! -> 얘는 풀린 걸 배열로 묶는다.  
배열 앞에 ... 를 찍으면 spread 연산자로서 동작하고 배열을 다 풀어버린다. 피연산자는 문자, 배열, map, set 등의 순회가능한 자료구조여야한다. 
sperad연산자를 사용한 배열을 인수로 전달할 수 있다. apply대신 썼던 것을 기억하자.  
배열을 배열 안에서 풀어서 concat처럼 쓸 수 있다.  
[...array, 4,5,6] 처럼.

