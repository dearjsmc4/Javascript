## DOM  
텍스트파일로 만들어진 웹 문서를 브라우저에 렌더링하려면 브라우저가 이해할 수 있는 구조로 메모리에 올려야한다. 브라우저의 렌더링 엔진은 웹 문서를 로드한 후 파싱한 결과를 브라우저가 이해할 수 있는 구조로 구성하여 메모리에 적재하는데, 이를 DOM이라 한다.  

**DOM 트리** : 트리를 만든다 -> 부자관계가 있다.  
HTML 텍스트문서를 파싱한 결과로, 메모리에 들어가있는 트리모양의 자료구조.  
우리가 작성한 구조 안에 돔트리를 컨트롤 할 수있는 DOM API가 있다면 자바스크립트파일을 실행할 때 그것들을 조작할 수 있다. 직접 메모리에 접근하여 돔트리구조 자체를 바꿔버린다. 변경된 DOM은 렌더링에 반영된다.  
DOM은 프로그래밍언어가 DOM에 접근하고 수정할 수 있도록 프로퍼티와 메소드를 갖는 자바스크립트 객체를 제공하는데 이를 DOM API라고 한다. 

- **노드**: 돔트리상의 하나하나의 가지 -> 엘리먼트라고도 한다.   
  - 문서노드 : 트리의 최상위에 존재하며, 돔트리의 시작점이다.  
  - 요소노드: HTML 요소를 표현한다. HTML 요소는 중첩에 의해 부자관계를 가지며 이를 통해 정보를 구조화한다.  
  - 어트리뷰트노드: HTML 요소의 어트리뷰트를 표현한다. 요소의 자식이 아니라 일부로 표현된다.  
  - 텍스트노드: HTML 요소의 텍스트를 표현한다. 돔트리의 최종단이다. 자식노드를 가질 수 없다. 

- HTMLCollection & NodeList  
`document.querySelector()`로 불러올 때는 NodeList라는 자료구조에 담아서 가져온다 -> Non live  
get 종류의 메소드로 불러오면 `HTMLCollection` 에 담겨서 온다 -> live (실시간으로 바뀐다)  
HTMLCollection은 유사배열객체이다. NodeList도 유사배열객체.  
가져온 유사배열 객체를 elem 이라는 변수에 담았다고 했을 때,  
```javascript
[...elems].forEach(elem => elem.className = 'blue');
```
유사배열객체를 배열로 반환하면 배열고차함수를 사용할 수 있다.  

## 동기식 & 비동기식  

동기라는건 순서가 보장된다는 뜻이다. 동기식 처리모델은 태스크가 순차적으로 실행되며, 하나의 태스크가 끝나기 전까지 다음 태스크가 실행되지 않는다. 따라서 서버에서 데이터를 가져올 때, 데이터가 응답될 때까지 다른 태스크들은 블로킹 상태에 놓인다.  
반대로 비동기는 실행 순서가 보장되지 않는다. 태스크가 병렬처리되며, 실행 중인 태스크가 끝나기를 기다리지 않고 다음 태스크를 실행한다. 

```javascript
function func1() {
  console.log('func1');
  func2();
}

function func2() {
  setTimeout(function() {
    console.log('func2');
  }, 0);

  func3();
}

function func3() {
  console.log('func3');
}

func1();
```

함수가 종료된다는 건 콜스택에서 빠진다는 말이다. setTimeout 함수는 0초가 경과하면 tick 이라는 이벤트가 발생하는데 그때 setTimeout 함수는 이벤트큐로 들어간다(큐는 선입선출이고 콜스택은 후입선출이다). 그리고 콜스택이 비었는지를 이벤트루프가 돌면서 체크하다가 콜스택이 비면 이벤트큐에서 이벤트를 콜스택에 넣는다. 즉 동기함수들이 모두 끝난 후에 가장 마지막에 실행된다.  

## 이벤트  

브라우저에서의 이벤트란 사용자의 클릭이나 키보드입력, 웹페이지가 로드되었을 때와 같은 것이다. 이는 DOM 요소와 관련이 있다. 이벤트가 발생하면 이를 감지할 수 있어야 하며, 그에 대응하는 처리를 호출해주어야 한다. 이를 통해 사용자와 웹페이지는 상호작용이 가능하게 된다.  

이벤트는 일반적으로 함수에 연결되며, 그 함수는 이벤트가 발생하기 전까지는 실행되지 않는다. 이 함수를 **이벤트 핸들러**라고 한다.


- 이벤트 루프와 동시성  

웹 애플리케이션에서 많은 태스크가 동시처리되는 것처럼 느껴지는데, 자바스크립트의 동시성을 지원하는 것이 이벤트루프이다. 이벤트 루프는 콜스택 내에 현재 실행중인 태스크가 있는지, 이벤트큐에 태스크가 있는지 반복하여 확인한다. 만약 콜스택이 비면 이벤트큐의 태스크가 콜스택으로 이동하여 실행된다.  

### 이벤트 핸들러 함수 내부의 this  
- 인라인 이벤트 핸들러 방식의 경우 이벤트 핸들러가 일반함수로서 호출되어 this는 전역객체를 가리킨다.  
- 이벤트 핸들러 프로퍼티 방식의 경우 이벤트 핸들러가 메소드이므로 this는 이벤트에 바인딩 된 요소를 가리킨다.  
- addEventListener 메소드 방식의 경우 이벤트 핸들러가 콜백함수이지만 이벤트 핸들러 내부의 this는 이벤트리스너에 바인딩 된 요소를 가리킨다.  

- 이벤트를 등록하는 세 가지 방법  
1. HTML 태그 안에 직접 함수를 호출  
2. **on 프로퍼티**를 이용한다. 원래 값이 null 인 상태인데 여기다 이벤트를 우리가 달아주면 된다.  
`btn.onclick = function foo() {}` -> 이벤트 핸들러 프로퍼티 방식  
여기서 foo 는 메소드이다. 프로퍼티의 값이 함수면 메소드니까.  
이벤트 핸들러를 하나밖에 달 수 없다. 두 개를 달면 덮어쓴다. HTML요소에만 쓸 수 있다.  
3. **addEventListener 메소드** 방식. 요소 선택 후에 `btn.addEventListener('click', function () {})` 이런 식으로 호출. 이때 인수로 함수를 주는거니까 콜백으로 주는 것이다. 클릭 이벤트가 발생하면 함수호출해달라는 뜻. HTML요소뿐 아니라 모든 돔요소에서 동작한다. 돔요소를 지정해주지 않으면 전역 어디에서든 이벤트가 동작한다.  

### 이벤트의 흐름  
HTML요소에 이벤트가 발생하면 이벤트가 전파되는데, 전파 방향에 따라 캡처링과 버블링으로 구분할 수 있다.  
이벤트가 시작되면 window에서부터 시작해서 지정된 요소까지 타고 내려간다 -> **캡처링**  
요소를 찍고 다시 window로 거슬러 올라간다 -> 기본값은 **버블링**
이벤트의 흐름은 캡처링부터 시작하여 버블링으로 종료한다. addEventListener 메소드의 세 번째 매개변수에 true를 설정하면 캡처링을 캐치하고, 미설정하면 버블링을 캐치한다.    

- **이벤트타겟**  
실제로 이벤트를 발생시킨 요소에 대한 참조.  
버튼이 여러개일때 내가 누른 '그' 버튼을 참조한다.  


### 이벤트 위임  
자식요소 여러 개에 이벤트 핸들러를 일일이 바인딩한다면 실행 속도가 느려질 뿐 아니라 코드도 길어진다. 그리고 동적으로 추가되는 요소의 경우 DOM에 아직 존재하지 않으므로 이벤트 핸들러를 바인딩 할 수 없는데, 이때 이벤트 위임을 사용한다. 하나의 부모요소에 이벤트 핸들러를 바인딩하는 것이다. div에 이벤트를 걸고, div 안에서 어떤 버튼이 이벤트를 발생시켰는지를 e.target과 버블링을 이용하여 잡아내는 원리를 이용한다.  

