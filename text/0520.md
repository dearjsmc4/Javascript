## 객체 리터럴 프로퍼티 기능 확장  

- 프로퍼티 축약 표현   
```javascript
let x = 1;
let y = 2;
const obj = { x, y };
```
프로퍼티 값으로 변수를 사용하는 경우, 프로퍼티 이름을 생략할 수 있다.  

- 프로퍼티 키 동적 생성  
```javascript
let prefix = 'prop';
let i = 0;
const obj = {};
obj[`${prefix}-${++i}`] = i;
obj[`${prefix}-${++i}`] = i;
obj[`${prefix}-${++i}`] = i;
```
ES5에서 프로퍼티 키를 동적으로 생성하려면 대괄호 표기법을 이용해야한다. 계산된 프로퍼티 이름이라고 한다.  
ES6에서는 객체 리터럴 내부에서도 프로퍼티 키를 동적으로 생성할 수 있다.  

- 메소드 축약표현  
```javascript
const obj = {
  name: 'Lee',
  sayHi() {
    console.log(`Hi, I am ${this.name}.`);
  }
};
```
ES6에서는 메소드 선언 시 function 키워드를 생략한 축약표현을 사용할 수 있다.  

- `__proto__` 프로퍼티에 의한 상속  
```javascript
const foo = {
  name: 'foo',
  sayHi() {
    console.log(`Hi, I am ${this.name}.`);
  }
};

const bar = {
  __proto__: foo,
  name: 'bar'
};

foo.sayHi();
bar.sayHi();
```
ES6에서는 객체 리터럴 내부에서 `__proto__` 프로퍼티를 직접 설정할 수 있다.  


## 클래스  

자바스크립트는 클래스가 필요없이 프로토타입과 클로저 등으로 객체 지향 프로그래밍이 가능하다. 하지만 클래스 기반 언어에 익숙하다면 자바스크립트의 프로그래밍 방식이 혼란스러울 수 있다. 그래서 자바스크립트에도 클래스처럼 동작하는 클래스가 생겼다. 생성자 함수보다 더 엄격하다.  

클래스 **선언은 런타임 전에** 이루어진다. 선언 이전에 참조하면 참조에러가 난다. let과 const처럼 일시적 사각지대에 빠진다. 호이스팅이 되지만 안 그런 것처럼 보인다.  

클래스 내부에 생성자함수와 유사한 역할을 하는 **constructor**가 있다. 만약 생략하면 자바스크립트엔진은 constructor가 있는 것처럼 생각하고 호출하며 빈 객체를 만든다. **new 연산자로 호출**하면 constructor 가 호출된다(가장 먼저, 단 한 번). 그리고 클래스필드 초기화를 해준다.  

클래스에서 메소드는 프로토타입을 써주지 않아도 **기본적으로 프로토타입 메소드**이다. 객체 리터럴에서 메소드를 선언하면 그 메소드는 객체리터럴의 것이지만 클래스에서는 인스턴스의 프로토타입의 것이다. 문법이 더 함축적이다.  

클래스에서는 우리가 프로퍼티라고 부르던 this **.name** 을 **클래스필드**라고 부른다. 멤버, 필드, 클래스필드, 인스턴스변수 등등으로 불리기도 한다. constructor는 객체를 직접 생산하고 프로퍼티를 초기화한다. 마치 생성자함수처럼 동작한다. constructor는 인수를 꼭 받을 필요는 없다. 인스턴스마다 다른 값을 가져야하는 프로퍼티가 있다면 그때 전달해주면 된다. 함수도 파라미터 정의할 때 무조건 지정해두진 않으니까.  클래스필드는 constructor 안에서 정의해야한다. constructor의 매개변수를 name = '' 으로 초기화해두면 undefined 가 아니라 빈 문자열이 나온다.  

### getter / setter  

- **getter** : 데이터프로퍼티에 **접근**  
함수 호출처럼 쓰는 게 아니다. 반드시 무언가를 반환한다. 데이터를 가지고 있지않다. 다른 프로퍼티의 데이터를 가지고 무언가를 해서 반환한다.  

- **setter** : 데이터프로퍼티에 값을 **셋팅**
셋팅을 하기위해 인수를 받는다. 반환하지 않는다.  


### 정적메소드  

**this를 쓰지않는** 메소드. hasOwnProperty 같은 프로토타입 메소드는 내부에서 꼭 this를 쓴다.  
static은 클래스에서만 쓸 수 있는 키워드이며 정적메소드를 뜻한다. 정적메소드는 생성자함수에 존재한다. 생성자함수에 놓은 의도는? 인스턴스 없이 호출할 수 있도록 만들어놓은 것. Math 객체를 떠올려보자. 비슷한 일들을 하는 메소드들을 모아놓은 객체였고, 인스턴스로 호출하지 않고 Math 객체에 직접 접근하여 사용할 수 있었다.  

### 클래스 상속  

**extends 키워드**는 부모클래스를 상속받는 자식클래스를 정의할 때 사용한다.  
-> `class 자식클래스 extends 부모클래스`  
프로토타입 기반일 때에는 상속 관계를 동적으로 결정할 수 있지만 클래스에서는 상속관계를 미리 결정해놓아야 한다. 자식클래스는 constructor 내에 부모를 나타내는 **super 키워드**가 있다. 부모클래스를 참조하거나 부모클래스의 생성자를 호출한다. super()는 부모의 생성자를 호출하며, new 연산자로 자식클래스의 인스턴스를 생성하면 호출된다. super 호출을 안하면 this를 쓰지 못한다.

## 디스트럭처링  

구조화된 배열 또는 객체를 비구조화하여 개별적인 변수에 할당한다. 필요한 값만을 추출하여 변수에 할당하거나 반환할 때 유용하다.  

### 배열 디스트럭처링  

```javascript
const arr = [1, 2, 3];
const [one, two, three] = arr; // 배열이 아니다!
```
ES6의 배열 디스트럭처링은 배열의 각 요소를 **인덱스 기준**으로 추출하여 변수 리스트에 할당한다. 배열 디스트럭처링을 위해서는 할당 연산자 왼쪽에 배열 형태의 변수 리스트가 필요하다. 예제는 const로 세 개의 변수를 선언하여 arr를 순차적으로 부숴서 할당한다. 반드시 뒤에 할당을 해주어야한다. 대괄호를 쓴 것은 `=` 뒤에 배열이 온다는 것이고 중괄호면 객체가 온다는 뜻이다. 

### 객체 디스트럭처링  

```javascript
const obj = { firstName: 'Yusoon', lastName: 'Hwang' };
const { lastName, firstName } = obj;
```
객체 디스트럭처링을 위해서는 할당 연산자 왼쪽에 객체 형태의 변수 리스트가 필요하다. 객체의 프로퍼티를 객체로부터 추출하여 변수 리스트에 할당하는데, 할당 기준은 **프로퍼티 키**이다. 예제는 두 개의 변수를 선언하고 이름이 같은 프로퍼티를 할당한다. 그러므로 순서가 무의미하다.  
중첩객체의 경우는 아래와 같다.  
```javascript
const me = {
  name: 'Yusoon',
  favorite: {
    drama: 'The Fiery Priest',
    movie: 'The Counselor'
  }
};

const { favorite: { movie } } = me;
```
