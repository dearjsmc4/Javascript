

## 7. 제어문  
코드는 원래 위에서부터 아래로 흐르며 순차적으로 진행되지만  
제어문을 사용하게 되면 그 흐름을 깨고 실행순서를 인위적으로 변경할 수 있다.  
그러나 코드의 흐름을 혼란스럽게 해 가독성을 해칠 수 있다.  

### 조건문  
주어진 조건식의 평가 결과(불리언 값)에 따라 코드 블록의 실행을 결정한다.  
- 블록문  
0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.  
```
질문1: 0개 이상이라는 것은 빈 블록도 가능하다는 뜻인가요. 빈 블록은 언제, 왜 쓰는 것인가요?  
```
만약 조건식의 평가 결과가 불리언값이 아니면 불리언값으로 강제 변환된다. 조건식의 평가 결과가 true 일 경우 if문 다음의 코드 블록이 실행되고, false 일 경우 else문 다음의 코드 블록이 실행된다. else if문을 사용해 조건식을 여러 개 추가할 수도 있다. if문과 else문은 2번 이상 사용할 수 없고, else if문은 여러 번 사용할 수 있다. 코드 블록 내에 문이 하나 뿐일 때에는 중괄호를 생략할 수도 있다.  
```
질문2:  
같은 함수 안에 if문을 두 번 써도 에러는 안 나는데 그냥 통상적으로 if는 두 번 쓰지 않기로 약속한 것인가요?  
```

- 삼항 조건 연산자로 바꿔쓰기
```
var a = 1;
a === 1 ? '맞다' : '아니다';
```
변수 a 에 값 1 을 할당하고  
a 가 1 이면 '맞다', 아니면 '아니다' 를 반환한다.  
삼항 조건 연산자 표현식은 값처럼 사용할 수 있으나 if...else 문은 값처럼 사용할 수 없다.  

- switch 문  
switch 문은 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용된다.  
if...else 문과 다른 점은, 코드 블록이 중괄호로 묶여 있지 않고 case문에 해당하는 문의 마지막에 break; 를 걸어주지 않으면 다음 case문으로  
폴스루된다는 것이다.  
**폴스루**: break 문이 없다면 표현식과 일치하는 case 문에 해당하는 문을 실행한 후 switch 문을 탈출하지 않고 다음 case 문으로 넘어가서 표현식이 일치하지 않더라도 case 문을 실행하게 된다.  



### 반복문  
주어진 조건식의 평가 결과가 true 인 경우에 코드 블록을 실행하고, 조건식이 거짓이 될 때까지 반복한다.  

- for 문  
조건식이 거짓이 될 때까지 코드블록을 반복 실행한다. 아래의 형태가 일반적인 for 문이며 for 문을 중첩하여 쓸 수도 있다.  
```
for([변수 선언문 또는 할당문]; [조건식]; [증감식])
{
    실행할 코드
}
```

- while 문  
주어진 조건식의 평가 결과가 참이면 코드 블록을 반복 실행하고 조건식의 평가 결과가 거짓이 되면 실행을 종료한다.  
```
while([조건식]){
    [실행할 코드]
}
```
조건식이 언제나 참이고 탈출 조건이 명시되어 있지 않으면 while 문은 무한으로 반복하게 된다.  
코드 블록 내에 if 문으로 탈출 조건을 만들고 break 를 걸어서 탈출할 수 있다.  

- do...while 문  
while 문과 비슷하지만, 코드 블록을 최소 한 번은 무조건 실행한 후에 조건식을 확인한다.  
```
do{
    [실행할 코드]
} while([조건식])
```


### break 문  
레이블 문, 반복문, switch 문의 코드 블록을 탈출한다. 
- 레이블 문 : 식별자가 붙은 문  


### continue 문  
반복문의 코드 블록 실행을 중단하고 증감식으로 이동한다.  


## 8. 타입 변환과 단축 평가  

개발자가 의도적으로 값의 타입을 변환하는 것을 **명시적 타입 변환**(Explicit coercion) 또는 타입 캐스팅(Type casting) 이라고 한다. 반면 개발자의 의도와 상관없이 자바스크립트 엔진이 암묵적으로 타입을 변환하는 것은 **암묵적 타입 변환**(Implicit coercion) 또는 타입 강제변환(Type coercion) 이라고 한다.  
`x.toString()` 이나 `x + ''` 등의 방법으로 타입 변환을 한다고 해도 원래 변수 x의 타입이 변하는 것은 아니다.  

- 암묵적 타입 변환이 어떻게 실행될까  
    1. `+` 연산자는 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작한다. 따라서 문자열 타입이 아닌 피연산자를 **문자열 타입**으로 변환한다.  
    2. 산술 연산자는 숫자 값을 만들어야 하므로, 숫자 타입이 아닌 피연산자를 모두 숫자 타입으로 변환한다. 비교 연산자나 단항 연산자도 마찬가지다. 만약 피연산자를 **숫자 타입**으로 바꿀 수 없을 때에는 NaN 의 결과가 나온다.  
    3. if 문이나 for 문 같은 제어문이나 삼항 조건 연산자의 조건식은 참/거짓 을 반환해야 하므로 조건식의 평가 결과를 Truthy 값 또는 Falsy 값으로 구분하여 **불리언 타입**으로 암묵적 변환한다. 

- 명시적 타입 변환  
```
질문3: 명시적 타입 변환 방법 중에 true * 1 가 있는데, 이 표현식의 평가 결과가 1로 나오는 것은 
산술 연산자 * 가 있고 산술 연산자는 숫자 값을 만들어야 하기 때문에 숫자타입이 아닌 true 를 
자바스크립트 엔진이 암묵적으로 숫자 타입으로 바꾸는 암묵적 타입 변환 아닌가요?  
산술연산자를 이용해 타입 변환을 하는 것은 명시적 타입 변환인가요, 암묵적 타입 변환인가요?  
```

- 단축 평가  
논리곱 연산자 `&&` 와 논리합 연산자 `||` 는 논리 평가를 결정한 피연산자를 그대로 반환한다.  


- *단축 평가를 사용한 매개변수의 기본값 설정에서 헷갈렸던 부분 정리*  

`undefined && true`  
undefined 은 falsy 값이므로 false 로 간주되어 undefined 을 반환한다.  
`undefined || true`  
undefined 이 falsy 값이어도 두 번째 피연산자가 true 인지 확인해야 하므로 true 를 반환한다.  

따라서  
```
function getStringLength(str) {
  str = str || '';
  return str.length;
}
```
`undefined || '';`  
getStringLength() 함수는 인자를 전달받지 않았을 경우 매개변수에 undefined 가 할당되고,  
undefined 는 falsy 값이므로 두 번째 피연산자까지 확인한 후 빈 문자열 '' 을 반환한다.  
함수는 undefined 의 length 가 아니라 빈 문자열의 length(0) 를 반환하게 된다.  


## 9. 객체 리터럴  

자바스크립트의 객체는 키(key)와 값(value)으로 구성된 프로퍼티(property)들의 집합이다. 프로퍼티들은 쉼표로 구분한다. 객체 리터럴은 중괄호 내에 0개 이상의 프로퍼티를 정의한다.  

- 프로퍼티의 키  
    - 빈 문자열을 포함하여 모든 문자열 또는 symbol 값을 사용할 수 있다.  
    - 그러나 빈 문자열은 키로서의 의미를 갖지 못하므로 권장하지 않는다.  
    - 문자열이나 symbol 값 외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 된다.  
    - 식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키의 경우 반드시 따옴표를 사용해야 한다.  
    - var, function 과 같은 예약어를 프로퍼티 키로 사용해도 에러는 없지만 권장하지 않는다.  
    - 프로퍼티 키를 중복선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어쓴다.  
    - 문자열이나 문자열로 변환 가능한 값을 반환하는 표현식으로 프로퍼티 키를 동적으로 생성할 수 있으며  
        이를 계산된 프로퍼티 이름(Computed Property name) 이라고 한다.  
```
질문4: 프로퍼티 키는 식별자 역할을 할 뿐 식별자는 아닌 건가요?  
존재하지 않는 프로퍼티 키에 접근했을 때 undefined 가 나오는 이유는 무엇인가요?  
```

- 프로퍼티의 값  
    - 자바스크립트에서 사용 가능한 모든 값을 사용할 수 있다.  
    - 프로퍼티 값이 함수일 경우 메소드(method) 라고 부른다.  
    - 이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.  
    - 존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 값이 할당된다.  

- 프로퍼티에 접근하는 방법  
    1. 마침표 표기법 : `person.name`  
    2. 대괄호 표기법  `person['name']` -> 따옴표로 감싸주지 않으면 식별자로 인식해 에러가 난다.  

- 프로퍼티 삭제  
    delete 연산자를 사용하며 존재하지 않는 프로퍼티를 삭제하려 할 경우 무시되고 에러가 나지 않는다.  
