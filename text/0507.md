## 원시 값  

**변경 불가능한 값.**  
변수와 헷갈리면 안 된다. 변수 자체가 값도 아닐 뿐더러, 변수는 당연히 변수값이 변한다. 그런데 변수가 가지고 있는 값 자체가 원시 값(숫자, 문자, 불리언, null, undefined, symbol)일 때 값은 바뀌지 않는다. 상수하고도 헷갈리면 안 된다. **상수도 값을 갖고 있을 수 있는 변수**이다. 단지 재할당을 못할 뿐. 그래서 변하지 않는 수라고 하면 상수하고 헷갈리기 쉽다.  
`const a = {};` 일 때는 빈 객체를 변경할 수 있다. 객체는 객체타입이며 변경가능한 값이기 때문이다. **변경 불가능하다는 것은 재할당 불가능하다는 것이 아니다.**  
<!-- 변수가 나쁜 건 아니지만 남발하면 안 좋다. 왜냐면 대부분의 에러가 변수때문에 나기 때문에. 따라서 변수는 스코프를 좁혀서 얼른 쓰고 얼른 버리는 게 좋다. 다른 곳에서 변경되지않도록.   -->
대부분의 언어에서 문자열은 객체로 취급받는데 자바스크립트는 원시 값으로 취급받는다. **재할당 이외의 방법으로는 절대 변할 수 없기 때문에 신뢰성이 보장**된다.  

원시값은 **값에 의한 전달**이 일어난다.  
-> 변수에 변수를 할당했을 때 무엇이 어떻게 전달되는가?  
```javascript
var foo = 10;
var bar = foo;
```
이때 변수 foo와 변수 bar의 값 10은 다른 메모리 공간에 저장되어있다.
foo가 가지고 있던 값 10을 그대로 복사해서 bar에게 할당하는 것인데, 이를 깊은 복사(deep copy)라고 한다.
서로 다른 메모리 공간에 저장되어있는 별개의 값이기 때문에 변수 foo의 값을 변경하여도 변수 bar에는 영향이 없다.  


## 객체  

객체를 할당한 변수가 확보한 메모리공간에는 객체가 실제로 저장된 메모리공간의 주소가 저장되어있고, 이를 **참조값**이라고 한다. 식별자가 객체를 가리키고 있는(point) 상태이다. 참조값(메모리주소) 자체는 원시값이라서 바꿀 수 없지만 메모리공간에 저장된 실제 객체는 변경 가능하다. 객체 리터럴이 평가되어 값이 된다는 건 메모리에 이진수로 저장된다는 말이다.  

**참조에 의한 전달**이 일어난다. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달된다. 이를 얕은 복사(shallow copy) 라고 한다. 그러나 두 개의 식별자가 한 객체를 공유한다는 건 한 쪽이 데이터를 변경하면 다른 한 쪽도 영향을 받으므로 부작용이 된다.  

```javascript
var person1 = {
  name: 'Lee'
};
var person2 = {
  name: 'Lee'
};
console.log(person1 === person2); // ①
console.log(person1.name === person2.name); // ②
```

1번은 false, 2번은 true 가 나온다.
객체 비교는 참조값이 달라서 false고, 2번은 원시값 비교('Lee')가 되기 때문에 true이다.



## 함수  

자바스크립트에서 가장 중요한 핵심개념.  
함수 안으로 필요한 정보를 밀어넣고(input) 값을 만들면 그 값을 내보낸다(output).
`function`은 **함수를 정의**하는 키워드이며, 함수는 함수 정의를 통해 생성한다.  
함수 정의만으로 함수가 실행되는 것은 아니고, **함수 호출**이라는 트리거가 있어야 한다. `return`은 옵션이고, return 을 안 쓰면 암묵적으로 undefined 가 반환된다(완료 값). 매개변수도 변수라서 인수가 할당된다. 매개변수는 함수 몸체 안에서만 유효하다.  

함수는 **재사용**을 위해 쓴다. 코드의 중복을 줄이고, 유지보수를 편리하게 한다. 실수가 줄어들고 품질도 좋아지고 돈도 적게 든다. 같은 코드가 여기저기 흩어져있으면 무언가를 고쳐야 할 때 여기저기 흩어진 코드에 다 찾아가서 고쳐줘야 한다.  


### 함수 리터럴의 구성요소  

- 함수명 : 함수 몸체 내에서만 유효한 식별자이다. 함수를 호출 할 때 보통 `foo();` 라고 하는데, 이때 foo 는 함수명이 아니라 자바스크립트 엔진이 함수명으로 암묵적으로 생성한 식별자이다.  

- 인자 (매개변수) = parameter : 인수가 할당된다. 함수 몸체 내에서 변수와 동일하게 취급된다.
  - 인수 = argument  

- 함수 몸체 : 함수가 호출되면 일괄적으로 실행할 문들을 코드블록으로 감싸놓은 부분이다.  

(+) 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.


### 함수 정의  

1. 함수 선언문  
```javascript
function foo(){
  console.log('hello');
}
```
함수 선언문은 함수명이 필수다.  
함수명 안 쓰고 변수에 할당하면 함수 표현식이 된다.  

2. 함수 표현식  
```javascript
var foo = function(){
  console.log('hello');
}
```
변수 선언문 + 할당문.  

3. Function 생성자 함수
```javascript
var add = new Function('x', 'y', 'return x + y');
```
함수를 생성할 때 주로 쓰이지는 않는다.  

4. 화살표 함수
```javascript
var add = (x, y) => x + y;
```
콜백함수에서 많이 쓰인다.  

### 함수 선언문과 함수 표현식  

함수 선언문을 썼을 때, 자바스크립트 엔진이 **암묵적으로 함수명과 같은 식별자를 등록**하여 식별자가 함수 객체를 가리키게 하고, 그 식별자를 이용해 함수를 호출하게 된다. 함수 표현식도 var 키워드로 인해 foo 라는 식별자가 등록이 되고 함수 객체를 가리키게 된다. 똑같이 동작하는 것 같지만 사실 조금 다르다. 만약 코드 상으로 함수를 정의하기 전에 호출을 먼저 하게 되면 함수 선언문의 경우 **함수 호이스팅**에 의해 hello 가 콘솔에 출력된다. 함수 선언문은 foo 라는 식별자를 만듦과 동시에 함수 객체까지 메모리공간에 할당해버리기 때문이다. 하지만 var 키워드를 이용한 함수 표현식은 foo 라는 식별자 등록만 되어있는 상태이기 때문에 호출하게 되면 foo 는 함수가 아니라는 에러가 뜬다.  

- 반환문 `return`  
  1. 리턴 키워드 뒤에 지정한 값을 반환.  
  2. 함수의 실행을 중단하고 함수몸체를 빠져나간다. 값을 리턴했는데 뭘 더 할 게 없으니까.  
  리턴 뒤에 어떤 값을 적지 않아도 된다. 그냥 함수를 빠져나갈 뿐.  


### 즉시실행함수  

정의와 동시에 호출되는 함수. 함수 정의하면 함수 객체가 만들어지고, 그 객체는 호출할 수 있으니까 끝에 () 로 호출. 단 한 번 호출할 수 있다. 그래서 뭐 함수명을 식별자로 만들고 어쩌구 저쩌구도 안한다. 그냥 메모리를 단 한 번 쓰고 사라진다. 이름을 붙여줄 수도 있지만 재귀를 하지 않는 이상 이름이 의미가 없다. 즉시실행함수는 반드시 그룹연산자 (...) 로 묶어주거나 function 키워드 앞에 `!` 이나 `+` 를 붙여주어야 한다. 보통 그룹연산자로 묶은 뒤 그 안에서 호출까지 한다.  
```javascript
(function () {
  [실행 코드]
}());
```

### 중첩 함수  

함수가 함수 안에서 정의되었다. 외부함수를 도와주는 헬퍼함수의 역할을 한다. 스코프와 연관이 있다. 외부함수도 스코프를 만들고 내부함수도 스코프를 만드니까 스코프도 중첩이 된다. 

### 콜백함수  

외부에서 밀어넣어주는 헬퍼함수. 두 함수를 합친다. 중첩함수는 태생적으로 함수 안에 있는거고 콜백은 밖에서 밀어넣어진다. 내가 넘기는 콜백함수에 따라 함수가 하는 일이 달라질 수 있다.


## 스코프

식별자는 값과 **바인딩**이 되어있다. 왜냐면 값 없이는 식별자는 의미가 없기 때문이다. 스코프는 상하관계가 있다. 이 상하관계는 중첩관계에 의해서 만들어진다. 중첩된 함수 내부에서 선언된 변수는 하위스코프에, 외부함수에서 선언된 변수는 상위스코프에. 전역변수는 전역스코프에 있다. 자바스크립트는 함수가 스코프를 만들고, 이것을 함수레벨스코프라고 한다(var 키워드가 지원하는...). let이나 const는 블록레벨스코프를 지원한다.  
똑같은 코드도 어디있느냐에 따라(문맥에 따라) 다르게 동작한다. 똑같은 말이라도 어떤 상황에서 하냐에 따라 다른 것처럼. 그 문맥이 스코프다.  
함수도 변수에 할당되기 때문에 스코프를 갖는다. 따라서 스코프는 "식별자를 검색하는 규칙" 이라고 표현하는 것이 적합하다.  


### 스코프체인  

자식객체는 부모객체의 자산을 쓸 수 있지만 그 반대는 안 된다. 하위스코프의 변수를 상위스코프에서 참조할 수 없다는 것이다. 변수를 참조할 때, 자바스크립트 엔진은 변수를 참조하는 코드의 스코프에서부터 상위스코프 방향으로 이동하며 변수를 검색한다. 상위스코프와 하위스코프가 계층적으로 연결된 것을 **스코프체인**이라고 한다. 스코프 체인의 최상위 스코프는 전역 스코프이다. 


### 함수레벨스코프  

var 키워드로 선언된 변수는 오로지 함수의 코드블록만을 지역스코프로 인정하는데, 이러한 특성을 함수레벨스코프라고 한다. 블록레벨스코프를 인정하지 않기 때문에 함수 밖에서 선언된 변수는 코드블록 내에서 선언되었다 할지라도 모두 전역변수가 된다. 


### 렉시컬 스코프  
```javascript
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

스코프가 결정되는데에는 두 가지 방식이 있다.  
1. 함수를 어디서 호출했는지에 따라 상위 스코프가 결정되거나  
2. 함수를 어디서 정의했는지에 따라 상위 스코프가 결정된다.  

자바스크립트는 **함수를 어디서 정의했는지**에 따라 상위 스코프가 결정된다. 즉 2번에 해당되고, 이를 **정적 스코프**, 또는 **렉시컬 스코프**라고 한다(1번은 동적 스코프라고 한다). 함수 bar 는 var x = 1; 과 같이 전역에서 정의되었기 때문에 bar 는 1를 출력한다. 만약 동적 스코프였다면 foo 함수 안에서 bar 가 호출되었기 때문에 foo 가 bar 의 상위 스코프가 되고, bar는 1이 아니라 10을 출력하게 될 것이다. 

