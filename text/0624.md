
- 상태는 stateful 컴포넌트에서만 관리한다.  
  다른 컴포넌트들은 상태를 직접적으로 고치지 않고, `stateful`(or `smart`) 컴포넌트에게 '의뢰' 한다. stateful 컴포넌트는, 상태를 직접 고칠 자격을 부여한 컴포넌트이다. 마치 사령관처럼! 자격이 없는 컴포넌트는 stateless 컴포넌트, 혹은 dumb 컴포넌트라고 한다. todos-container 는 다른 컴포넌트들을 호출할 뿐, 자신만의 템플릿은 없다. 즉, 다른 컴포넌트들을 관장하는 것이다. stateless 의 주 역할은, view 만 생성하는 것이다. view를 생성하기 위한 상태데이터는 container 가 보내주어야 한다. 만약 stateless 에서 상태가 변하면(인풋에 데이터가 입력되었다거나 하는) 상태 변경에 필요한 데이터를 보내줄 뿐, 직접 변경하진 않는다. 

- ngModel content
  양방향 데이터 바인딩. 템플릿에서 변경된 값을 클래스 컴포넌트에 갱신하고, 클래스 컴포넌트에서 변경된 값은 템플릿에 갱신된다. 따라서 인풋에 글자가 한 자 한자 입력될때마다 클래스 컴포넌트의 content에 갱신되고, 인풋 폼의 값은 content와 항상 같다. 

- 앵귤러의 css style
  컴포넌트의 스코프 단위로 적용된다. 

- 변화감지 매커니즘
  이 매커니즘을 이해하는 것은 어려운 일이니, 일단 참조를 바꾸는 것에 중점을 두자. 그래서 변화감지를 하기 쉽게 만들어주자.

## 디렉티브  

컴포넌트들의 **공통된 기능**이 있다면, 그 기능을 빼내서 디렉티브로 만든다.  
디렉티브의 셀렉터는, 대괄호 안에 있는 텍스트가 어트리뷰트로써 사용될 것이라는 뜻이다. css의 셀렉터문법에서 어트리뷰트는 대괄호를 이용해 지정했었다.  
`input[type=text]` => input 태그이고, type 이라는 어트리뷰트 값이 text인 요소를 선택  
디렉티브의 셀렉터를 클래스로써 사용하고 싶다면 대괄호대신 `.`을 붙여주면 된다. 그러나 가급적 어트리뷰트로 사용하기로 한다.  
디렉티브는, 호스트요소를 서포트한다.  
- `public el: ElementRef`  
  '앵귤러야, ElementRef 타입의 객체를 생성해서 내게 인수로 전달해줘.' => 의존성주입  
el이라는 참조를 디렉티브 전역에서 사용할 수 있게 된다. public 이기때문에.  
el은 객체이며, 이 객체는 프로퍼티로 호스트요소를 가지고 있다.  
그래서 `el.nativeElement.style.color = "blue";` 으로 할 수 있지만 보안문제로 쓰지않는다.  
  -> **Renderer2** 를 쓰자. DOM을 컨트롤할때 쓰는 API를 제공한다.  
`this.renderer.setStyle(this.el.nativeElement, 'color', 'blue');`
  -> 위와 동일하게 동작한다. 
`@HostListener()` : 이벤트를 적용한다. 
`window.pageYOffset` : 스크롤이 얼마나 되었는지 잡아낸다. 


