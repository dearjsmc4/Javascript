## Angular Directive  

### 디렉티브  

"DOM의 모든 것(모양이나 동작 등)을 관리하기 위한 지시(명령)" 이다.  
HTML 요소 또는 어트리뷰트의 형태로 사용하여 디렉티브가 사용된 요소에게 무언가를 하라는 지시를 전달한다. 애플리케이션 전역에서 사용할 수 있는 공통 관심사를 컴포넌트에서 분리한 것으로, 컴포넌트의 복잡성을 낮추고 가독성을 향상시킨다.  
- `@Directive` 데코레이터 : 디렉티브의 설정 정보가 기술된 메타데이터 객체를 인자로 전달받아 디렉티브 생성  
- 단일 책임 원칙: 여러 요소에서 공통적/반복적으로 사용될 하나의 기능을 명확히 구현해야 함  

- 컴포넌트 : 
  뷰를 구성하는 독립적 구성요소. 뷰 단위의 관심사. 다른 컴포넌트를 자식으로 가질 수 있다.  
- 디렉티브 : 
  보편적이며, DOM 요소 공통 기능에 관심. 뷰가 없으므로 자식을 가질 수 없다.  

### 사용자 정의 어트리뷰트 디렉티브  

- `$ ng generate directive [디렉티브명]` : 디렉티브 추가  
- 디렉티브의 식별자는 @Directive 메타데이터 객체의 selector 프로퍼티에 지정  
- 생성자에 ElementRef 타입의 인스턴스 주입(의존성 주입)  
  템플릿 내부의 DOM 요소를 감싼 래퍼객체를 생성.  
  네이티브 DOM 요소를 가리키는 nativeElement 프로퍼티를 소유한다.  
  주입된 ElementRef 클래스의 인스턴스를 통해 호스트 요소에 직접 접근할 수 있다.  
    -> XSS 공격에 노출될 수 있는 단점이 있으므로 **Renderer2** 의 인스턴스를 주입받도록 한다.  
- 모듈의 @NgModule 의 선언부에 디렉티브 추가 -> 컴포넌트에서 사용할 수 있게 된다  
- `<p textBlue>textBlue directive</p>` : p 요소는 어트리뷰트 호스트가 된다.  

- 이벤트 처리 : 
  `@HostListener` 데코레이터 : 호스트 요소의 이벤트에 대한 핸들러 정의. 호스트 요소의 이벤트를 수신.  

- @Input 데이터 바인딩 :  
  `@Input` 데코레이터를 사용하여 호스트 요소에서 프로퍼티 바인딩한 값을 전달받는다.  
  프로퍼티 바인딩에 의한 동적 값과 일반 어트리뷰트의 정적 값 모두 @Input 데코레이터를 통해 전달할 수 있다.  

### 사용자 정의 구조 디렉티브  

- ng-template 디렉티브  
  ngIf, ngFor, ngSwitch와 같은 빌트인 구조 디렉티브는 *(asterisk)에 의해 ng-template으로 변환된다. Angular는 *ngIf 를 만나면 호스트 요소를 ng-template 디렉티브로 래핑하고 ngIf를 프로퍼티 바인딩으로 변환한다. 
  `*ngIf="expression"` === `[ngIf]="expression"`  
  ng-template 디렉티브는 ngIf에 바인딩 된 값이 참으로 평가되면 래핑된 요소를 뷰에 렌더링되고, 거짓일 때에는 DOM 에서 제거(주석처리되어 완전히 제거)된다. 이때 ngIf 디렉티브는 의존성 주입을 통해 주입받은 `TemplateRef`와 `ViewContainerRef`의 인스턴스를 사용한다.  
  - TemplateRef: ng-template 디렉티브로 래핑된 요소를 가리키는 객체를 생성. 
  - ViewContainerRef: 하나 이상의 뷰를 포함시킬 수 있는, 새로운 요소를 DOM에 삽입하기 위해 필요한 컨테이너.
    `createComponent`, `createEmbeddedView` 메소드를 통해 새로운 요소를 DOM에 삽입한다.  

- ng-container 디렉티브  
  단순히 디렉티브를 선언하기 위한 태그가 필요할 때 사용한다. `*`문법을 사용할 수 있으며, 동일한 요소에 하나 이상의 *ngIf 또는 *ngFor와 같은 구조 디렉티브를 사용하기 위한 헬퍼 요소로서 사용한다.

## Angular Pipe  
익숙하지 않은 형태의 데이터를 읽기 쉬운 형식으로, 데이터 자체를 변경하지 않고 화면에 표시하는 형식만 변경하고 싶을 때 사용한다.  

### 빌트인 파이프  
Angular 는 다양한 빌트인 파이프를 지원한다.  
- date / json / uppercase / lowercase / currency / percent  
  / decimal / slice / async
( pre태그 안에 {{ todos | json }} 해서 화면에 띄웠던 것이 파이프를 이용한 것이었다! )  

### 체이닝 파이프  
여러 개의 파이프를 조합하여 결과를 출력한다.  
`{{ name | slice:4 | uppercase }}` -> 4번째 문자부터 마지막 문자까지 잘라 대문자로 출력  

### 커스텀 파이프  
- `$ ng generate pipe [파이프명]`  
-  @Pipe 메타데이터 객체의 name 프로퍼티에 파이프의 식별자를 지정  
  -> 파이프 클래스는 PipeTransform 인터페이스의 추상 메소드 transform을 구현해야 한다.  
  `transform(value: any, ...args: any[]): any`  
- 모듈의 선언부에 등록 : Angular CLI 로 파이프 생성 시 자동 등록  
- 사용 방법은 빌트인 파이프와 같다.  

### 파이프와 변화 감지  
뷰와 모델의 동기화를 유지하기 위해 상태 변화를 감지하고 이를 반영한다.  
데이터 바인딩은 변화 감지 매커니즘을 토대로 수행된다.  

### 순수 파이프와 비순수 파이프  
- 비순수 파이프 : @Pipe 메타데이터 객체의 pure 프로퍼티에 false를 지정
  -> 파이프가 빈번하게 호출되어 퍼포먼스가 좋지 않음  
- 순수 파이프 : pure 프로퍼티를 생략  
  -> 원시 타입 값 또는 객체 참조의 변경과 같은 순수한 변경만을 감지하고 파이프를 실행.  

## Angular Lifecycle Hooks  

생명주기는 디렉티브가 생성하고 소멸되기까지의 여러 과정을 말한다. Angular는 생명주기를 통해 컴포넌트와 디렉티브를 생성하고 렌더링하며, 프로퍼티의 변화를 체크하고 DOM에서 제거하는 일련의 과정을 관리한다. 

### 생명주기 훅 메소드 (Lifecycle hooks)  
생명주기 훅 메소드는 인터페이스의 형태로 제공된다.  
생명주기에는 동일한 이름의 인터페이스가 존재하며, 인터페이스는 생명주기 이름 앞에 ng 가 붙은 추상메소드를 포함한다. -> OnInit에 처리되어야 할 행위를 정의하려면 인터페이스 OnInit의 추상메소드 ngOnInit을 구현한다.  

- ngOnChanges  
  부모 컴포넌트에서 자식 컴포넌트의 입력 프로퍼티(@Input 데코레이터로 장식된 프로퍼티)로 바인딩한 값이 초기화 또는 변경되었을 때 실행된다. ngOnInit 이전에 입력 프로퍼티가 존재하는 경우, 최소 1회 호출되고 그 후엔 입력 프로퍼티가 변경될 때마다 반복 호출된다. 원시 타입의 값이 재할당되었을 때와 객체의 참조가 변경되었을 때만 반응한다. 

- ngOnInit  
  ngOnChanges 이후, 입력 프로퍼티를 포함한 모든 프로퍼티의 초기화가 완료된 시점에 한 번만 호출된다. Angular의 경우 프로퍼티 초기화 처리는 constructor가 아닌 ngOnInit에서 수행하는 것이 좋다.  

- ngDoCheck  
  ngOnInit 이후, 컴포넌트 또는 디렉티브의 모든 상태 변화가 발생할 때(변화 감지 로직이 실행될 때)마다 호출된다. Angular의 변화 감지에 의해 감지되지 않거나 감지할 수 없는 변경 사항을 수동으로 더티 체크(dirty check)하기 위해 사용한다. 하지만 모든 상태 변화가 발생할 때마다 호출되기 때문에 성능에 악영향을 줄 수 있다.  

- ngOnChanges & ngDoCheck  
  ngOnChanges는 입력 프로퍼티의 초기화, 입력 프로퍼티의 참조 변경 시에 호출된다.  
  반면 ngDoCheck는 *모든* 상태 변화 시점, 즉 변화 감지(Change detection) 로직이 실행될 때 호출된다.  


